declare class Connector {
    readonly port: MessagePort;
    readonly peerVersion: string | undefined;
    readonly sessionID: number | undefined;
    static version: string;
    static sessionID: number;
    connected: boolean;
    onClose?: () => void;
    onMessage?: (data: any) => void;
    constructor(port: MessagePort, peerVersion: string | undefined, sessionID: number | undefined);
    /**
     * Send message to the other side
     * e.g. server send to client or client to server
     * @param message message content
     */
    send(message: any): void;
    on(type: "close" | "message", handle: (data?: string) => void): void;
    get version(): {
        self: string;
        peer: string | undefined;
    };
    close(): void;
    static newSessionID(): number;
    /**
     * Client connect
     * @param targetWindow
     * @param origins
     * @returns
     */
    static connect(targetWindow: any, origins: string[]): Promise<Connector>;
    /**
     * Server listen
     * @param origin
     * @param handler
     * @returns
     */
    static accepts(origin: string, handler: (connector: Connector) => void): () => void;
    static accept(origin: string): Promise<Connector>;
}

declare type RPCMethod = (...params: any[]) => Promise<any>;
declare class JsonRPCServer {
    readonly connector: Connector;
    readonly methods: {
        [method: string]: RPCMethod;
    };
    constructor(connector: Connector, methods: {
        [method: string]: RPCMethod;
    });
    private onRequest;
    notify(type: string, data: any[]): void;
    get version(): {
        self: string;
        peer: string | undefined;
    };
    private onClose;
}

interface Account {
    publicKey: string[];
    address: string;
    authKey: string;
    minKeysRequired: number;
}
interface LegacyAccount {
    address: string;
    publicKey: string;
}
declare type Option = Partial<{
    max_gas_amount: string | bigint;
    gas_unit_price: string | bigint;
    expiration_timestamp_secs: string | bigint;
    sequence_number: string | bigint;
    sender: string;
}>;
declare type Array<T> = T[];
declare type Base = string | number | BigInt | Uint8Array | boolean;
declare type Arg<T> = T | Array<Base>;
declare type Args = Array<Arg<Base>>;
declare type Payload = {
    function: string;
    type_arguments: string[];
    arguments: Args;
} | Uint8Array;
interface WalletAPI {
    connect(): Promise<Account>;
    disconnect(): Promise<void>;
    isConnected(): Promise<boolean>;
    network(): Promise<string>;
    account(): Promise<Account>;
    chainId(): Promise<Number>;
    signAndSubmit(payload: Payload, option?: Option): Promise<Uint8Array>;
    signTransaction(payload: Payload, option?: Option): Promise<Uint8Array>;
    signMessage(message: string | Uint8Array): Promise<Uint8Array>;
}
declare enum WalletEvent {
    ChangeAccount = "ChangeAccountEvent",
    ChangeNetwork = "ChangeNetworkEvent"
}
declare enum WalletRPC {
    connect = "connect",
    disconnect = "disconnect",
    isConnected = "isConnected",
    network = "network",
    account = "account",
    chainId = "chainId",
    signAndSubmit = "signAndSubmit",
    signTransaction = "signTransaction",
    signMessage = "signMessage"
}
interface LegacyWalletAPI {
    connect(): Promise<LegacyAccount>;
    disconnect(): Promise<void>;
    isConnected(): Promise<boolean>;
    network(): Promise<string>;
    account(): Promise<LegacyAccount>;
    chainId(): Promise<Number>;
    signAndSubmit(payload: Payload, option?: Option): Promise<Uint8Array>;
    signTransaction(payload: Payload, option?: Option): Promise<Uint8Array>;
    signMessage(message: string | Uint8Array): Promise<Uint8Array>;
}
declare function adaptLegacyAccount(methods: WalletAPI): LegacyWalletAPI;

declare class MSafeServer {
    server: JsonRPCServer;
    constructor(connector: Connector, methods: WalletAPI);
    changeNetwork(network: string): void;
    changeAccount(account: Account): void;
    get version(): {
        self: string;
        peer: string | undefined;
    };
}

declare type executorFunc = (data: any) => void;
declare type executor = {
    resolve: executorFunc;
    reject: executorFunc;
};
declare type notifier = (...params: any[]) => void;
declare class JsonRPCClient {
    readonly connector: Connector;
    readonly notifiers: {
        [type: string]: notifier;
    };
    id: number;
    executors: {
        [id: number]: executor;
    };
    constructor(connector: Connector, notifiers: {
        [type: string]: notifier;
    });
    private onMessage;
    request(method: string, params?: any[]): Promise<any>;
    get version(): {
        self: string;
        peer: string | undefined;
    };
    private onNotify;
    private onClose;
}

declare type onEventFunc = (data: any) => void;
declare const MSafeOrigins: {
    mainnet: string;
    testnet: string;
    partner: string;
    legacy1: string;
    legacy2: string;
    legacy3: string;
    local: string;
};
declare type MSafeNetwork = NetworkType | string;
declare type MSafeNetworks = MSafeNetwork | MSafeNetwork[];
declare type NetworkType = keyof typeof MSafeOrigins;
declare class MSafeWallet implements WalletAPI {
    client: JsonRPCClient;
    events: {
        [key: string]: onEventFunc;
    };
    constructor(connector: Connector);
    connect(): Promise<Account>;
    isConnected(): Promise<boolean>;
    disconnect(): Promise<any>;
    onChangeAccount(cbk: (account: Account) => void): void;
    onChangeNetwork(cbk: (network: string) => void): void;
    network(): Promise<string>;
    account(): Promise<Account>;
    chainId(): Promise<Number>;
    signAndSubmit(payload: Payload, option?: Option): Promise<Uint8Array>;
    signTransaction(payload: Payload, option?: Option): Promise<Uint8Array>;
    signMessage(message: string | Uint8Array): Promise<Uint8Array>;
    get version(): {
        self: string;
        peer: string | undefined;
    };
    /**
     * @description check if current page is running under MSafe wallet
     */
    static inMSafeWallet(): boolean;
    /**
     * @deprecated use inMSafeWallet instead
     */
    static inMsafeWallet(): boolean;
    /**
     * @description Get msafe dapp url, which can be used to open dapp under msafe wallet.
     * @param msafe network type or msafe website url
     * @param dappUrl dapp url
     */
    static getAppUrl(msafe?: MSafeNetwork, dappUrl?: string): string;
    /**
     * @description Get msafe origin by network type or url
     * @param msafeNetwork type or msafe website url
     * @returns msafe origin
     */
    static getOrigin(msafeNetwork?: MSafeNetwork): string;
    /**
     * @description Open msafe wallet and establish communication with the msafe website.
     *              The allowlist is used to check if the msafe website is trusted.
     * @param allowlist allowlist of msafe website url, omit means accpets all msafe websites. you can pass a single url or an array of urls.
     * @returns MSafeWallet instance
     * @example
     *  // 1. Initialize MSafeWallet with default allowlist:
     *      const wallet = await MSafeWallet.new();
     *  // 2. Initialize MSafeWallet with a single MSafe url:
     *      const wallet = await MSafeWallet.new('https://app.m-safe.io');
     *  // 3. Initialize MSafeWallet with an array of MSafe urls:
     *      const wallet = await MSafeWallet.new(['https://app.m-safe.io', 'https://testnet.m-safe.io', 'https://partner.m-safe.io']);
     *  // 4. Initialize MSafeWallet with a single network type:
     *      const wallet = await MSafeWallet.new('Mainnet');
     *  // 5. Initialize MSafeWallet with an array of network types:
     *      const wallet = await MSafeWallet.new(['Mainnet', 'Testnet', 'Partner']);
     */
    static new(allowlist?: MSafeNetworks): Promise<MSafeWallet>;
}
/**
 * @deprecated use MSafeWallet instead, it will be removed in the future.
 */
declare class MsafeWallet extends MSafeWallet {
}

declare function encode<T>(data: T): Uint8Array;
declare function decode<T>(data: Uint8Array): T;
declare function encodeToStr<T>(data: T): string;
declare function decodeFromStr<T>(data: string): T;

declare function toLegacyAccount(account: Account): LegacyAccount;

export { Account, Connector, JsonRPCClient, JsonRPCServer, LegacyAccount, MSafeServer, MSafeWallet, MsafeWallet, Option, Payload, WalletAPI, WalletEvent, WalletRPC, adaptLegacyAccount, decode, decodeFromStr, encode, encodeToStr, toLegacyAccount };
