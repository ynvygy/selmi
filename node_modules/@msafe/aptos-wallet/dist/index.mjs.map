{"version":3,"sources":["../src/JsonRPCServer.ts","../src/coder.ts","../src/utils.ts","../src/version.ts","../src/WalletAPI.ts","../src/MSafeServer.ts","../src/HandshakeMessage.ts","../src/connector.ts","../src/JsonRPCClient.ts","../src/MSafeWallet.ts"],"sourcesContent":["import {\n  JsonRpcError,\n  JsonRpcParamsSchemaByPositional,\n  JsonRpcPayloadRequest,\n  format,\n  parse,\n} from \"json-rpc-protocol\";\nimport { Connector } from \"./connector\";\nimport { decodeFromStr, encodeToStr } from \"./coder\";\n\ntype RPCMethod = (...params: any[]) => Promise<any>;\n\nexport class JsonRPCServer {\n  constructor(\n    public readonly connector: Connector,\n    readonly methods: { [method: string]: RPCMethod }\n  ) {\n    this.connector.on(\"message\", (data) => this.onRequest(data!));\n    this.connector.on(\"close\", () => this.onClose());\n  }\n\n  private onRequest(data: string) {\n    const req = parse(data) as JsonRpcPayloadRequest;\n    if (req.type !== \"request\") return;\n    const method = this.methods[req.method];\n    if (method === undefined) {\n      const resp = format.error(req.id, new JsonRpcError(\"method not exist\"));\n      this.connector.send(resp);\n      return;\n    }\n    method(\n      ...(req.params as JsonRpcParamsSchemaByPositional).map((param) =>\n        decodeFromStr(param)\n      )\n    )\n      .then((response) => {\n        const resp = format.response(req.id, encodeToStr(response));\n        this.connector.send(resp);\n      })\n      .catch((err) => {\n        const resp = format.error(req.id, new JsonRpcError(String(err)));\n        this.connector.send(resp);\n      });\n  }\n\n  notify(type: string, data: any[]) {\n    const notification = format.notification(type, data.map(encodeToStr));\n    this.connector.send(notification);\n  }\n\n  get version() {\n    return this.connector.version;\n  }\n\n  private onClose() {}\n}\n","import { Buffer } from \"buffer\";\nenum Type {\n  Boolean,\n  Number,\n  BigInt,\n  String,\n  Uint8Array,\n  Object,\n  Array,\n  Undefined,\n  Null,\n}\n\nfunction concat(list: Uint8Array[]): Uint8Array {\n  const total = list.reduce((size, a) => size + a.length, 0);\n  const arr = new Uint8Array(total);\n  let offset = 0;\n  list.forEach((a) => {\n    arr.set(a, offset);\n    offset += a.length;\n  });\n  return arr;\n}\n\nclass Decoder {\n  constructor(\n    readonly data: Uint8Array,\n    private byteOffset = data.byteOffset\n  ) {}\n\n  read(byteLength: number): Uint8Array {\n    const result = new Uint8Array(\n      this.data.buffer,\n      this.byteOffset,\n      byteLength\n    );\n    this.byteOffset += byteLength;\n    return result;\n  }\n\n  decodeBigInt(): bigint {\n    return BigInt(this.decodeString());\n  }\n\n  decodeNumber(): number {\n    return Number(this.decodeString());\n  }\n\n  decodeUint8Array(): Uint8Array {\n    const length = new Uint32Array(this.read(4).slice(0).buffer)[0];\n    return this.read(length);\n  }\n\n  decodeBoolean(): boolean {\n    return Boolean(this.read(1)[0]);\n  }\n\n  decodeString(): string {\n    const de = this.decodeUint8Array();\n    return Buffer.from(de).toString();\n  }\n\n  decodeArray(): any[] {\n    const length = this.decode<number>(); // decodeNumber\n    return Array(length)\n      .fill(0)\n      .map(() => this.decode());\n  }\n\n  decodeObject(): { [key: string]: any } {\n    const length = this.decode<number>(); // decodeNumber\n    const entries = Array(length)\n      .fill(0)\n      .map(() => [this.decode<string>(), this.decode()]);\n    return Object.fromEntries(entries);\n  }\n\n  decode<T>(): T {\n    const type = this.read(1)[0] as Type;\n    switch (type) {\n      case Type.BigInt:\n        return this.decodeBigInt() as any;\n      case Type.Number:\n        return this.decodeNumber() as any;\n      case Type.Boolean:\n        return this.decodeBoolean() as any;\n      case Type.String:\n        return this.decodeString() as any;\n      case Type.Uint8Array:\n        return this.decodeUint8Array() as any;\n      case Type.Array:\n        return this.decodeArray() as any;\n      case Type.Object:\n        return this.decodeObject() as any;\n      case Type.Undefined:\n        return undefined as any;\n      case Type.Null:\n        return null as any;\n    }\n    throw `unkonw type: ${type}`;\n  }\n}\n\nfunction encodeUint8Array(data: Uint8Array): Uint8Array {\n  const en = new Uint8Array(data.length + 5);\n  en[0] = Type.Uint8Array;\n  Buffer.from(en.buffer, 1, 4).writeUInt32LE(data.length);\n  en.set(data, 5);\n  return en;\n}\n\nfunction encodeUndefined(): Uint8Array {\n  return Uint8Array.from([Type.Undefined]);\n}\n\nfunction encodeNull(): Uint8Array {\n  return Uint8Array.from([Type.Null]);\n}\n\nfunction encodeBigInt(data: bigint): Uint8Array {\n  const en = encodeString(data.toString());\n  en[0] = Type.BigInt;\n  return en;\n}\n\nfunction encodeNumber(data: number): Uint8Array {\n  const en = encodeString(data.toString());\n  en[0] = Type.Number;\n  return en;\n}\n\nfunction encodeBoolean(data: boolean): Uint8Array {\n  return new Uint8Array([Type.Boolean, Number(data)]);\n}\n\nfunction encodeString(data: string): Uint8Array {\n  const buf = new ArrayBuffer(data.length);\n  Buffer.from(buf).write(data);\n  const en = encodeUint8Array(new Uint8Array(buf));\n  en[0] = Type.String;\n  return en;\n}\n\nfunction encodeObject(data: { [key: string]: any }): Uint8Array {\n  const entries = Object.entries(data);\n  const ens = entries.map(([key, value]) => {\n    const keyBuf = encode<string>(key);\n    const valueBuf = encode(value);\n    return concat([keyBuf, valueBuf]);\n  });\n  return concat([\n    Uint8Array.from([Type.Object]),\n    encode<number>(entries.length),\n    ...ens,\n  ]);\n}\n\nfunction encodeArray(data: any[]): Uint8Array {\n  const ens = data.map((elem) => encode(elem));\n  return concat([\n    Uint8Array.from([Type.Array]),\n    encode<number>(ens.length),\n    ...ens,\n  ]);\n}\n\nexport function encode<T>(data: T): Uint8Array {\n  if (data instanceof Uint8Array) {\n    return encodeUint8Array(data);\n  }\n  if (data instanceof Array) {\n    return encodeArray(data);\n  }\n  if (data instanceof Object) {\n    return encodeObject(data);\n  }\n  if (data === null) {\n    return encodeNull();\n  }\n  switch (typeof data) {\n    case \"string\":\n      return encodeString(data);\n    case \"number\":\n      return encodeNumber(data);\n    case \"bigint\":\n      return encodeBigInt(data);\n    case \"boolean\":\n      return encodeBoolean(data);\n    case \"undefined\":\n      return encodeUndefined();\n  }\n  throw `unsuport type: ${data}`;\n}\n\nexport function decode<T>(data: Uint8Array): T {\n  const decoder = new Decoder(data);\n  return decoder.decode();\n}\n\nexport function encodeToStr<T>(data: T): string {\n  return Buffer.from(encode(data).buffer).toString(\"hex\");\n}\n\nexport function decodeFromStr<T>(data: string): T {\n  const buffer = new ArrayBuffer(data.length / 2);\n  Buffer.from(buffer).write(data, \"hex\");\n  return decode(new Uint8Array(buffer));\n}\n","import { Account, LegacyAccount } from \"./WalletAPI\";\n\nexport function toLegacyAccount(account: Account): LegacyAccount {\n  return {\n    address: account.address,\n    publicKey: convertPKsToMultiSigPK(\n      account.publicKey,\n      account.minKeysRequired\n    ),\n  };\n}\n\nfunction convertPKsToMultiSigPK(pks: string[], threshold: number) {\n  let msPk = pks\n    .map((pk) => (pk.startsWith(\"0x\") ? pk.substring(2) : pk))\n    .join(\"\");\n  msPk += threshold.toString(16).padStart(2, \"0\");\n  return \"0x\" + msPk;\n}\n","/// Versions that introduces new features.\nexport enum Versions {\n  ALLOWLIST = \"2.0.5\", // version that enable allowlist\n  SESSION_ID = \"2.1.4\", // version that enable session id\n}\n\n/// Compare two version strings.\nexport function cmp(a: string, b: string): number {\n  const parse = (version: string) => version.split(\".\").map(Number);\n  const [majorA, minorA, batchA] = parse(a);\n  const [majorB, minorB, batchB] = parse(b);\n  if (majorA > majorB) return 1;\n  if (majorA < majorB) return -1;\n  if (minorA > minorB) return 1;\n  if (minorA < minorB) return -1;\n  if (batchA > batchB) return 1;\n  if (batchA < batchB) return -1;\n  return 0;\n}\n\nexport function isSessionIDVersion(version: string | undefined): boolean {\n  return version !== undefined && cmp(version, Versions.SESSION_ID) >= 0;\n}\n\n/// Check if the version is enable allowlist.\nexport function isAllowList(version: string | undefined): boolean {\n  return version !== undefined && cmp(version, Versions.ALLOWLIST) >= 0;\n}\n\nexport function isMultiSigFormatVersion(version: string | undefined): boolean {\n  return version !== undefined;\n}\n\n/// Check if the version is enable versioned handshake message.\nexport function isVersionedHandshakeVersion(\n  version: string | undefined\n): boolean {\n  return version !== undefined;\n}\n","import { toLegacyAccount } from \"./utils\";\n\nexport interface Account {\n  publicKey: string[];\n  address: string;\n  authKey: string;\n  minKeysRequired: number;\n}\n\nexport interface LegacyAccount {\n  address: string;\n  publicKey: string;\n}\n\nexport type Option = Partial<{\n  max_gas_amount: string | bigint;\n  gas_unit_price: string | bigint;\n  expiration_timestamp_secs: string | bigint;\n  sequence_number: string | bigint;\n  sender: string;\n}>;\n\ntype Array<T> = T[];\ntype Base = string | number | BigInt | Uint8Array | boolean;\ntype Arg<T> = T | Array<Base>;\ntype Args = Array<Arg<Base>>;\n\nexport type Payload =\n  | {\n      function: string;\n      type_arguments: string[];\n      arguments: Args;\n    }\n  | Uint8Array;\n\nexport interface WalletAPI {\n  connect(): Promise<Account>;\n  disconnect(): Promise<void>;\n  isConnected(): Promise<boolean>;\n  network(): Promise<string>;\n  account(): Promise<Account>;\n  chainId(): Promise<Number>;\n  signAndSubmit(payload: Payload, option?: Option): Promise<Uint8Array>;\n  signTransaction(payload: Payload, option?: Option): Promise<Uint8Array>;\n  signMessage(message: string | Uint8Array): Promise<Uint8Array>;\n}\n\nexport enum WalletEvent {\n  ChangeAccount = \"ChangeAccountEvent\",\n  ChangeNetwork = \"ChangeNetworkEvent\",\n}\n\nexport enum WalletRPC {\n  connect = \"connect\",\n  disconnect = \"disconnect\",\n  isConnected = \"isConnected\",\n  network = \"network\",\n  account = \"account\",\n  chainId = \"chainId\",\n  signAndSubmit = \"signAndSubmit\",\n  signTransaction = \"signTransaction\",\n  signMessage = \"signMessage\",\n}\n\n// LegacyWalletAPI is the adapted version of walletAPI.\n// It allows backward compatibility with legacy clients with account format `LegacyAccount`\ninterface LegacyWalletAPI {\n  connect(): Promise<LegacyAccount>;\n  disconnect(): Promise<void>;\n  isConnected(): Promise<boolean>;\n  network(): Promise<string>;\n  account(): Promise<LegacyAccount>;\n  chainId(): Promise<Number>;\n  signAndSubmit(payload: Payload, option?: Option): Promise<Uint8Array>;\n  signTransaction(payload: Payload, option?: Option): Promise<Uint8Array>;\n  signMessage(message: string | Uint8Array): Promise<Uint8Array>;\n}\n\nexport function adaptLegacyAccount(methods: WalletAPI): LegacyWalletAPI {\n  // Adapt legacy account\n  return {\n    connect(): Promise<LegacyAccount> {\n      return methods.connect().then((account) => toLegacyAccount(account));\n    },\n    disconnect(): Promise<void> {\n      return methods.disconnect();\n    },\n    isConnected(): Promise<boolean> {\n      return methods.isConnected();\n    },\n    network(): Promise<string> {\n      return methods.network();\n    },\n    account(): Promise<LegacyAccount> {\n      return methods.account().then((account) => toLegacyAccount(account));\n    },\n    chainId(): Promise<Number> {\n      return methods.chainId();\n    },\n    signAndSubmit(payload: Payload, option?: Option): Promise<Uint8Array> {\n      return methods.signAndSubmit(payload, option);\n    },\n    signTransaction(payload: Payload, option?: Option): Promise<Uint8Array> {\n      return methods.signTransaction(payload, option);\n    },\n    signMessage(message: string | Uint8Array): Promise<Uint8Array> {\n      return methods.signMessage(message);\n    },\n  };\n}\n","import { Connector } from \"./connector\";\nimport { JsonRPCServer } from \"./JsonRPCServer\";\nimport { toLegacyAccount } from \"./utils\";\nimport { isMultiSigFormatVersion } from \"./version\";\nimport {\n  Account,\n  adaptLegacyAccount,\n  WalletAPI,\n  WalletEvent,\n} from \"./WalletAPI\";\n\nexport class MSafeServer {\n  public server: JsonRPCServer;\n\n  constructor(connector: Connector, methods: WalletAPI) {\n    if (isMultiSigFormatVersion(connector.version.peer)) {\n      this.server = new JsonRPCServer(connector, methods as any);\n    } else {\n      // backward compatibility\n      const legacyWalletAPI = adaptLegacyAccount(methods);\n      this.server = new JsonRPCServer(connector, legacyWalletAPI as any);\n    }\n  }\n\n  changeNetwork(network: string) {\n    this.server.notify(WalletEvent.ChangeNetwork, [network]);\n  }\n\n  changeAccount(account: Account) {\n    const peerVersion = this.version.peer;\n    if (isMultiSigFormatVersion(peerVersion)) {\n      this.server.notify(WalletEvent.ChangeAccount, [account]);\n    } else {\n      const legacyAccount = toLegacyAccount(account);\n      this.server.notify(WalletEvent.ChangeAccount, [legacyAccount]);\n    }\n  }\n\n  get version() {\n    return this.server.version;\n  }\n}\n","import { isSessionIDVersion, isVersionedHandshakeVersion } from \"./version\";\n\nexport class HandshakeMessage {\n  static HANDSHAKE_REQ = \"HANDSHAKE_REQ\";\n  static HANDSHAKE_ACK = \"HANDSHAKE_ACK\";\n  static HANDSHAKE_PORT_ACK = \"HANDSHAKE_PORT_REQ\";\n  handshakeType: string;\n  version: string | undefined;\n  sessionID: number | undefined;\n  constructor(handshakeType: string, version?: string, sessionID?: number) {\n    this.handshakeType = handshakeType;\n    if (version !== undefined) this.version = version;\n    if (sessionID !== undefined) this.sessionID = sessionID;\n  }\n\n  // When responding to a lower-version client, a lower-version message is required.\n  toString(messageVersion: string | undefined): string {\n    if (isSessionIDVersion(messageVersion)) {\n      if (this.sessionID === undefined) throw Error(\"sessionID is undefined\");\n      return `${this.handshakeType}:${this.version}:${this.sessionID}`;\n    }\n    if (isVersionedHandshakeVersion(messageVersion))\n      return `${this.handshakeType}:${this.version}`;\n    return this.handshakeType;\n  }\n\n  isHandshakeMessage(handshakeType: string): boolean {\n    if (this.handshakeType !== handshakeType) return false;\n    if (isSessionIDVersion(this.version) && this.sessionID === undefined)\n      return false;\n    return true;\n  }\n\n  static fromString(message: string): HandshakeMessage {\n    const [handshakeType, version, sessionID] = message.split(\":\");\n    return new HandshakeMessage(handshakeType, version, Number(sessionID));\n  }\n}\n","import { version } from \"../package.json\";\nimport { HandshakeMessage } from \"./HandshakeMessage\";\nimport { isAllowList, isSessionIDVersion } from \"./version\";\n\nexport class Connector {\n  static version = version;\n  static sessionID = 0;\n  connected = true;\n  onClose?: () => void;\n  onMessage?: (data: any) => void;\n\n  constructor(\n    public readonly port: MessagePort,\n    public readonly peerVersion: string | undefined,\n    public readonly sessionID: number | undefined\n  ) {\n    this.port.onmessage = (event) => {\n      this.onMessage && this.onMessage(event.data);\n    };\n    this.port.onmessageerror = () => {\n      this.close();\n    };\n  }\n\n  /**\n   * Send message to the other side\n   * e.g. server send to client or client to server\n   * @param message message content\n   */\n  send(message: any) {\n    this.port.postMessage(message);\n  }\n\n  on(type: \"close\" | \"message\", handle: (data?: string) => void) {\n    switch (type) {\n      case \"close\":\n        this.onClose = handle;\n        break;\n      case \"message\":\n        this.onMessage = handle;\n        break;\n      default:\n        throw Error(\"invalid type\");\n    }\n  }\n\n  get version() {\n    return {\n      self: Connector.version,\n      peer: this.peerVersion,\n    };\n  }\n\n  close() {\n    if (this.connected) {\n      this.port.close();\n      this.connected = false;\n      this.onClose && this.onClose();\n    }\n  }\n\n  static newSessionID() {\n    return Connector.sessionID++;\n  }\n\n  /**\n   * Client connect\n   * @param targetWindow\n   * @param origins\n   * @returns\n   */\n  static async connect(\n    targetWindow: any,\n    origins: string[]\n  ): Promise<Connector> {\n    return new Promise((resolve, rejected) => {\n      const sessionID = Connector.newSessionID();\n      let cleaner = () => {};\n      let timer = setTimeout(() => {\n        cleaner();\n        rejected(`Connect MSafe wallet timeout: ${sessionID}`);\n      }, 1000);\n      const handle = (event: MessageEvent) => {\n        const port = event.ports[0];\n        if (!origins.includes(event.origin)) return;\n        if (typeof event.data !== \"string\") return;\n        const handshakeMessage = HandshakeMessage.fromString(event.data);\n        if (\n          !handshakeMessage.isHandshakeMessage(\n            HandshakeMessage.HANDSHAKE_PORT_ACK\n          )\n        )\n          return;\n        if (handshakeMessage.sessionID !== sessionID) return;\n        cleaner();\n        resolve(new Connector(port, handshakeMessage.version, sessionID));\n      };\n      cleaner = () => {\n        clearTimeout(timer);\n        window.removeEventListener(\"message\", handle);\n      };\n      window.addEventListener(\"message\", handle);\n      const handshakeMessage = new HandshakeMessage(\n        HandshakeMessage.HANDSHAKE_REQ,\n        Connector.version,\n        sessionID\n      );\n      targetWindow.postMessage(\n        handshakeMessage.toString(handshakeMessage.version),\n        \"*\"\n      );\n    });\n  }\n\n  /**\n   * Server listen\n   * @param origin\n   * @param handler\n   * @returns\n   */\n  static accepts(\n    origin: string,\n    handler: (connector: Connector) => void\n  ): () => void {\n    origin = new URL(origin).origin;\n    const handle = (event: MessageEvent) => {\n      if (event.origin !== origin) return;\n      if (typeof event.data !== \"string\") return;\n\n      const handshakeMessage = HandshakeMessage.fromString(event.data);\n\n      if (!handshakeMessage.isHandshakeMessage(HandshakeMessage.HANDSHAKE_REQ))\n        return;\n\n      const peerVersion = handshakeMessage.version;\n      const thisVersion = Connector.version;\n\n      if (isSessionIDVersion(peerVersion)) {\n        const channelPair = new MessageChannel();\n        const replyMessage = new HandshakeMessage(\n          HandshakeMessage.HANDSHAKE_PORT_ACK,\n          thisVersion,\n          handshakeMessage.sessionID\n        );\n        (event.source as Window).postMessage(\n          replyMessage.toString(peerVersion),\n          event.origin,\n          [channelPair.port2]\n        );\n        handler(\n          new Connector(\n            channelPair.port1,\n            peerVersion,\n            handshakeMessage.sessionID\n          )\n        );\n      } else if (isAllowList(peerVersion)) {\n        const channelPair = new MessageChannel();\n        const replyMessage = new HandshakeMessage(\n          HandshakeMessage.HANDSHAKE_PORT_ACK,\n          thisVersion\n        );\n        (event.source as Window).postMessage(\n          replyMessage.toString(peerVersion),\n          event.origin,\n          [channelPair.port2]\n        );\n        handler(new Connector(channelPair.port1, peerVersion, undefined));\n      } else {\n        const port = event.ports[0];\n        const replyMessage = new HandshakeMessage(\n          HandshakeMessage.HANDSHAKE_ACK,\n          thisVersion\n        );\n        port.postMessage(replyMessage.toString(peerVersion));\n        handler(new Connector(event.ports[0], peerVersion, undefined));\n      }\n    };\n\n    window.addEventListener(\"message\", handle);\n    return () => window.removeEventListener(\"message\", handle);\n  }\n\n  static async accept(origin: string): Promise<Connector> {\n    return new Promise((resolve) => {\n      const cleaner = this.accepts(origin, (connector) => {\n        resolve(connector);\n        cleaner();\n      });\n    });\n  }\n}\n","import {\n  JsonRpcParamsSchemaByPositional,\n  JsonRpcPayloadError,\n  JsonRpcPayloadNotification,\n  JsonRpcPayloadResponse,\n  format,\n  parse,\n} from \"json-rpc-protocol\";\nimport { Connector } from \"./connector\";\nimport { decodeFromStr, encodeToStr } from \"./coder\";\n\ntype executorFunc = (data: any) => void;\ntype executor = { resolve: executorFunc; reject: executorFunc };\ntype notifier = (...params: any[]) => void;\n\nexport class JsonRPCClient {\n  id: number = 0;\n  executors: { [id: number]: executor } = {};\n  constructor(\n    public readonly connector: Connector,\n    readonly notifiers: { [type: string]: notifier }\n  ) {\n    this.connector.on(\"message\", (data) => this.onMessage(data!));\n    this.connector.on(\"close\", () => this.onClose());\n  }\n  private onMessage(data: string) {\n    const message = parse(data) as\n      | JsonRpcPayloadResponse\n      | JsonRpcPayloadNotification\n      | JsonRpcPayloadError;\n    switch (message.type) {\n      case \"notification\":\n        return this.onNotify(\n          message.method,\n          (message.params as JsonRpcParamsSchemaByPositional).map(decodeFromStr)\n        );\n      case \"response\":\n        const { resolve } = this.executors[Number(message.id)];\n        delete this.executors[Number(message.id)];\n        return resolve(decodeFromStr(message.result));\n      case \"error\":\n        const { reject } = this.executors[Number(message.id)];\n        delete this.executors[Number(message.id)];\n        return reject(message.error.message);\n    }\n  }\n  async request(method: string, params: any[] = []): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const reqId = this.id++;\n      this.executors[reqId] = { resolve, reject };\n      const req = format.request(reqId, method, params.map(encodeToStr));\n      this.connector.send(req);\n    });\n  }\n  get version() {\n    return this.connector.version;\n  }\n  private onNotify(type: string, data: any[]) {\n    this.notifiers[type](...data);\n  }\n  private onClose() {}\n}\n","import { Connector } from \"./connector\";\nimport { JsonRPCClient } from \"./JsonRPCClient\";\nimport {\n  Account,\n  Option,\n  Payload,\n  WalletAPI,\n  WalletEvent,\n  WalletRPC,\n} from \"./WalletAPI\";\ntype onEventFunc = (data: any) => void;\n\n/// MSafe website urls, it acts as the default allowlist.\nconst MSafeOrigins = {\n  mainnet: \"https://aptos.m-safe.io\",\n  testnet: \"https://aptos-testnet.m-safe.io\",\n  partner: \"https://aptos-preview.m-safe.io\",\n  legacy1: \"https://app.m-safe.io\",\n  legacy2: \"https://testnet.m-safe.io\",\n  legacy3: \"https://partner.m-safe.io\",\n  local: \"http://localhost:5173\",\n};\n/// Default list of MSafe endpoint URLs.\nconst DefaultMSafeEndpoints = Object.values(MSafeOrigins);\n\n/// NetworkType or MSafe website url as string.\ntype MSafeNetwork = NetworkType | string;\n/// MSafeNetwork or array of MSafeNetwork.\ntype MSafeNetworks = MSafeNetwork | MSafeNetwork[];\n/// Network type of MSafe websites.\n/// It can be 'Mainnet', 'Testnet' or 'Partner'.\ntype NetworkType = keyof typeof MSafeOrigins;\n\nexport class MSafeWallet implements WalletAPI {\n  public client: JsonRPCClient;\n\n  events: { [key: string]: onEventFunc } = {};\n\n  constructor(connector: Connector) {\n    const onEvent = (type: string, ...params: any[]) => {\n      const cbk = this.events[type];\n      cbk && cbk(params[0]);\n    };\n    const entries = [WalletEvent.ChangeAccount, WalletEvent.ChangeNetwork].map(\n      (event) => [event, (...params: any[]) => onEvent(event, ...params)]\n    );\n    const notifiers = Object.fromEntries(entries);\n    this.client = new JsonRPCClient(connector, notifiers);\n  }\n\n  async connect(): Promise<Account> {\n    return this.client.request(WalletRPC.connect);\n  }\n\n  async isConnected(): Promise<boolean> {\n    return this.client.request(WalletRPC.isConnected);\n  }\n\n  async disconnect() {\n    return this.client.request(WalletRPC.disconnect);\n  }\n\n  onChangeAccount(cbk: (account: Account) => void) {\n    this.events[WalletEvent.ChangeAccount] = cbk;\n  }\n\n  onChangeNetwork(cbk: (network: string) => void) {\n    this.events[WalletEvent.ChangeNetwork] = cbk;\n  }\n\n  async network(): Promise<string> {\n    return this.client.request(WalletRPC.network);\n  }\n\n  async account(): Promise<Account> {\n    return this.client.request(WalletRPC.account);\n  }\n\n  async chainId(): Promise<Number> {\n    return this.client.request(WalletRPC.chainId);\n  }\n\n  async signAndSubmit(payload: Payload, option?: Option): Promise<Uint8Array> {\n    return this.client.request(WalletRPC.signAndSubmit, [payload, option]);\n  }\n\n  async signTransaction(\n    payload: Payload,\n    option?: Option\n  ): Promise<Uint8Array> {\n    return this.client.request(WalletRPC.signTransaction, [payload, option]);\n  }\n\n  async signMessage(message: string | Uint8Array): Promise<Uint8Array> {\n    return this.client.request(WalletRPC.signMessage, [message]);\n  }\n\n  get version() {\n    return this.client.version;\n  }\n\n  /**\n   * @description check if current page is running under MSafe wallet\n   */\n  static inMSafeWallet(): boolean {\n    return (\n      typeof window !== \"undefined\" &&\n      typeof document !== \"undefined\" &&\n      typeof parent !== \"undefined\" &&\n      typeof parent.window !== \"undefined\" &&\n      parent.window !== window\n    );\n  }\n  /**\n   * @deprecated use inMSafeWallet instead\n   */\n  static inMsafeWallet(): boolean {\n    return MSafeWallet.inMSafeWallet();\n  }\n\n  /**\n   * @description Get msafe dapp url, which can be used to open dapp under msafe wallet.\n   * @param msafe network type or msafe website url\n   * @param dappUrl dapp url\n   */\n  static getAppUrl(\n    msafe: MSafeNetwork = \"mainnet\",\n    dappUrl = `${window.location.href}`\n  ): string {\n    const msafeOrigin = MSafeWallet.getOrigin(msafe);\n    return `${msafeOrigin}/store/0?url=${encodeURIComponent(dappUrl)}`;\n  }\n\n  /**\n   * @description Get msafe origin by network type or url\n   * @param msafeNetwork type or msafe website url\n   * @returns msafe origin\n   */\n  static getOrigin(msafeNetwork: MSafeNetwork = \"mainnet\"): string {\n    const endpoint =\n      MSafeOrigins[msafeNetwork.toLowerCase() as NetworkType] || msafeNetwork;\n    return new URL(endpoint).origin;\n  }\n\n  /**\n   * @description Open msafe wallet and establish communication with the msafe website.\n   *              The allowlist is used to check if the msafe website is trusted.\n   * @param allowlist allowlist of msafe website url, omit means accpets all msafe websites. you can pass a single url or an array of urls.\n   * @returns MSafeWallet instance\n   * @example\n   *  // 1. Initialize MSafeWallet with default allowlist:\n   *      const wallet = await MSafeWallet.new();\n   *  // 2. Initialize MSafeWallet with a single MSafe url:\n   *      const wallet = await MSafeWallet.new('https://app.m-safe.io');\n   *  // 3. Initialize MSafeWallet with an array of MSafe urls:\n   *      const wallet = await MSafeWallet.new(['https://app.m-safe.io', 'https://testnet.m-safe.io', 'https://partner.m-safe.io']);\n   *  // 4. Initialize MSafeWallet with a single network type:\n   *      const wallet = await MSafeWallet.new('Mainnet');\n   *  // 5. Initialize MSafeWallet with an array of network types:\n   *      const wallet = await MSafeWallet.new(['Mainnet', 'Testnet', 'Partner']);\n   */\n  static async new(\n    allowlist: MSafeNetworks = DefaultMSafeEndpoints\n  ): Promise<MSafeWallet> {\n    const msafeOrigin =\n      allowlist instanceof Array\n        ? allowlist.map((m) => MSafeWallet.getOrigin(m))\n        : [MSafeWallet.getOrigin(allowlist)];\n    const connector = await Connector.connect(\n      window.parent,\n      DefaultMSafeEndpoints.map((m) => MSafeWallet.getOrigin(m))\n    );\n    return new MSafeWallet(connector);\n  }\n}\n\n/**\n * @deprecated use MSafeWallet instead, it will be removed in the future.\n */\nexport class MsafeWallet extends MSafeWallet {}\n"],"mappings":"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","names":["parse","version","WalletEvent","WalletRPC","version","handshakeMessage","format","parse","parse","format"]}