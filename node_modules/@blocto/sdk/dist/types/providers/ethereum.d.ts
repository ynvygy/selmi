import { ProviderAccounts } from 'eip1193-provider';
import BloctoProvider from './blocto';
import { EIP1193RequestPayload, EthereumProviderConfig, EthereumProviderInterface, AddEthereumChainParameter, JsonRpcRequest, JsonRpcResponse, JsonRpcCallback, SwitchableNetwork, IUserOperation } from './types/ethereum.d';
import { KEY_SESSION } from '../constants';
export default class EthereumProvider extends BloctoProvider implements EthereumProviderInterface {
    #private;
    chainId: `0x${string}`;
    networkVersion: `${number}`;
    rpc: string;
    injectedWalletServer?: string;
    appId: string;
    _blocto: {
        unloadedNetwork?: AddEthereumChainParameter[];
        sessionKeyEnv: KEY_SESSION;
        walletServer: string;
        blockchainName: string;
        networkType: string;
        switchableNetwork: SwitchableNetwork;
    };
    private get existedSDK();
    constructor(config: EthereumProviderConfig);
    send(methodOrPayload: string | JsonRpcRequest, paramsOrCallback: Array<unknown> | JsonRpcCallback): Promise<void | JsonRpcResponse>;
    sendAsync(payload: JsonRpcRequest | Array<JsonRpcRequest> | Array<EIP1193RequestPayload>, callback?: JsonRpcCallback): Promise<JsonRpcResponse | Array<JsonRpcResponse> | void>;
    /**
     * Sending userOperation using Blocto SDK.
     * @param {IUserOperation} userOp - userOperation object
     * @remarks No need to include nonce, initCode, and signature as parameters when using BloctoSDK to send userOperation.
     * These parameters will be ignored.
     * @returns {Promise<string>} - userOperation hash
     */
    sendUserOperation(userOp: IUserOperation): Promise<string>;
    request(payload: EIP1193RequestPayload | Array<EIP1193RequestPayload>): Promise<any>;
    bloctoApi<T>(url: string, options?: RequestInit): Promise<T>;
    responseListener(frame: HTMLIFrameElement, objectKey: string): Promise<any>;
    setIframe(url: string, blockchain?: string): Promise<HTMLIFrameElement>;
    enable(email?: string): Promise<ProviderAccounts>;
    fetchAccounts(): Promise<ProviderAccounts>;
    handleReadRequests(payload: EIP1193RequestPayload): Promise<any>;
    handleSign({ method, params }: EIP1193RequestPayload): Promise<string>;
    private handleSwitchChain;
    handleSendTransaction(payload: EIP1193RequestPayload): Promise<string>;
    handleSendBatchTransaction(payload: EIP1193RequestPayload): Promise<string>;
    handleSendUserOperation(payload: EIP1193RequestPayload): Promise<string>;
    handleBundler(payload: EIP1193RequestPayload): Promise<JSON>;
    handleDisconnect(): Promise<void>;
    loadSwitchableNetwork(networkList: AddEthereumChainParameter[]): Promise<null>;
    supportChainList(): Promise<{
        chainId: string;
        chainName: string;
    }[]>;
    on(event: string, listener: (arg: any) => void): void;
    removeListener(event: string, listener: (arg: any) => void): void;
    off: (event: string, listener: (arg: any) => void) => void;
}
